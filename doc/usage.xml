<chapter id="usage">
<title>Usage</title>

<sect1 id="about">
<title>About &MDT;</title>

<sect2 id="overview">
<title>Overview</title>

<para>
&MDT; prepares a raw frequency table, given information from &MODELLER;
alignments and/or &PDB; files. It can also process the raw frequency table in
several ways (e.g., normalization with
<ulink url="&epydoc;Table.normalize">Table.normalize</ulink>, smoothing with
<ulink url="&epydoc;Table.smooth">Table.smooth</ulink>), perform entropy
calculations with
<ulink url="&epydoc;Table.entropy_full">Table.entropy_full</ulink>, and write
out the data in various formats, including for plotting by &ASGL;
(<ulink url="&epydoc;Table.write_asgl">Table.write_asgl</ulink>) and use as
restraints by &MODELLER;.
</para>

<para>
More precisely, &MDT; uses a sample of sequences, structures, and/or
alignments to construct a table N(a,b,c,...,d) for features a, b, c, ..., d.
The sample for generating the frequencies N is obtained depending on the type
of features a, b, c, ..., d. The sample can contain individual proteins, pairs
of proteins, pairs of residues in proteins, pairs of aligned residues, pairs
of aligned pairs of residues, chemical bonds, angles, dihedral angles, and
pairs of tuples of atoms. Some features work with triple alignments, too.
All the needed features a, b, c, ..., d are calculated automatically from the
sequences, alignments, and/or &PDB; files. The feature bins are defined in
a bin file which can be changed by the user.
</para>

<para>
&MDT; works by accumulating the table N by processing each sequence or alignment
in turn. See
<ulink url="&epydoc;Table.add_alignment">Table.add_alignment</ulink>.
</para>
</sect2>

<sect2 id="features">
<title>&MDT; features</title>

<para>
A 'feature' in &MDT; is simply some binnable property of your input alignment.
Example features include the
<ulink url="&epydoc;features.ResidueType">residue type</ulink>,
<ulink url="&epydoc;features.Chi1Dihedral">&chi;<subscript>1</subscript></ulink>
and <ulink url="&epydoc;features.PhiDihedral">&Phi;</ulink> dihedral angles,
<ulink url="&epydoc;features.SequenceIdentity">sequence identity</ulink>
between two sequences,
<ulink url="&epydoc;features.XRayResolution">X-ray resolution</ulink>,
<ulink url="&epydoc;features.AtomDistance">atom-atom distances</ulink>,
<ulink url="&epydoc;features.AtomType">atom type</ulink>, and
<ulink url="&epydoc;features.BondLength">bond length</ulink>.
</para>

<para>
&MDT; understands that different features act on different sets of proteins,
or parts of proteins, and will automatically scan over the correct range to
collect necessary statistics (e.g. when you call
<ulink url="&epydoc;Table.add_alignment">Table.add_alignment</ulink>).
For example, to collect statistics for the residue type feature, it is
necessary to scan all residues in all proteins in the alignment. The
X-ray resolution feature, on the other hand, only requires each protein
in the alignment to be scanned, not each residue.
The atom-atom distance feature requires scanning over all pairs of atoms in
all proteins in the alignment, while the sequence identity feature requires
scanning all pairs of proteins in the alignment. If you construct a table of
multiple features, the most fine-grained of the features determines the scan -
for example, a table of X-ray resolution against &Phi; dihedral would require
a scan of all residues.
See <xref linkend="scantypes" /> for all of the scan types.
</para>

<para>
When choosing which proteins to scan, &MDT; also considers the features. It
will scan each protein individually, all pairs of proteins, or all triples of
proteins. The latter two scans only happen if you have features in your table
that require multiple proteins (e.g.
<ulink url="&epydoc;features.ProteinPair">ProteinPair</ulink> or
<ulink url="&epydoc;features.AlignedResidue">AlignedResidue</ulink>
features) or you have single-protein features such as
<ulink url="&epydoc;features.Protein">Protein</ulink> or
<ulink url="&epydoc;features.Residue">Residue</ulink>
but you have asked to evaluate them on the second or third protein (by setting
the <varname>protein</varname> argument to 1 or 2 rather than the default 0).
</para>

<para>
&MDT; also knows that some
<ulink url="&epydoc;features.ResiduePair">residue pair</ulink> or
<ulink url="&epydoc;features.AtomPair">atom pair</ulink> features are symmetric,
and will perform a non-redundant scan in this case. If, however, any feature
in the table is asymmetric, a full scan is performed. If in doubt, you can query
<ulink url="&epydoc;Table.symmetric">Table.symmetric</ulink> to see whether
a symmetric scan will be performed for the current set of features.
(Currently, any <ulink url="&epydoc;features.TuplePair">tuple pair</ulink>
feature in your table forces a full scan.)
</para>

<para>
The feature bins determine how to convert a feature value into a frequency
table.
For most feature types, you can specify how many bins to use, and their value
ranges - see <xref linkend="binspec" /> for more information. The last bin
is always reserved as an 'undefined' bin, for values that don't fall into
any other bin<footnote>
<para>
You can, however, remove the 'undefined' bin using
<ulink url="&epydoc;Table.reshape">Table.reshape</ulink>.
</para>
</footnote>.
(Some features are predetermined by the setup of the system - for
example, the <ulink url="&epydoc;features.ResidueType">residue type</ulink>
feature always has 22 bins - 20 for the standard amino acids, 1 for gaps in
the alignment, and 1 for undefined.)
</para>

<table id="scantypes">
<title>Scan types</title>
<tgroup cols="2">
<thead>
  <row><entry>Type</entry><entry>Example feature</entry></row>
</thead>
<tbody>

<row>
<entry>Protein</entry>
<entry><ulink url="&epydoc;features.XRayResolution">X-ray
resolution</ulink></entry>
</row>

<row>
<entry>Residue<footnote id="resatompair">
<para>
Residue and residue pair scans are also used for 'one atom per residue'
features, such as
<ulink url="&epydoc;features.ResidueDistance">ResidueDistance</ulink>,
which is the distance between the 'special
atom' in two residues. This special atom is usually
C<subscript>&alpha;</subscript>, but can be overridden by specifying the
<varname>distance_atoms</varname> parameter when creating the
<ulink url="&epydoc;Library">Library</ulink> object.
</para>
</footnote></entry>
<entry><ulink url="&epydoc;features.Chi1Dihedral">&chi;<subscript>1</subscript>
dihedral</ulink></entry>
</row>

<row>
<entry>Residue pair<footnoteref linkend="resatompair" />
<footnote id="pos2feature">
<para>
When looking at pairs of atoms or residues, it is useful to extract information
about the 'other' atom or residue in the pair. This other atom or residue is
termed 'pos2' in &MDT;, and can be asked for when creating the feature.
For example, when building a table of atom-atom distances
(<ulink url="&epydoc;features.AtomDistance">AtomDistance</ulink> feature)
it may be useful to tabulate it against the atom types of both the
first atom. This is done by also using two copies of the
<ulink url="&epydoc;features.AtomType">AtomType</ulink>, the second with
<varname>pos2=True</varname>.
</para>
</footnote>
</entry>
<entry><ulink url="&epydoc;features.ResidueIndexDifference">Residue index
difference</ulink></entry>
</row>

<row>
<entry>Atom</entry>
<entry><ulink url="&epydoc;features.AtomType">&MODELLER;
atom type</ulink></entry>
</row>

<row>
<entry>Atom pair<footnoteref linkend="pos2feature" /></entry>
<entry><ulink url="&epydoc;features.AtomDistance">Distance between
two atoms</ulink></entry>
</row>

<row>
<entry>Atom tuple</entry>
<entry><ulink url="&epydoc;features.TupleType">Atom tuple type</ulink></entry>
</row>

<row>
<entry>Atom tuple pair</entry>
<entry><ulink url="&epydoc;features.TupleDistance">Atom tuple non-bonded
distance</ulink></entry>
</row>

<row>
<entry>Chemical bond</entry>
<entry><ulink url="&epydoc;features.BondType">Bond type</ulink></entry>
</row>

<row>
<entry>Chemical angle</entry>
<entry><ulink url="&epydoc;features.Angle">Bond angle</ulink></entry>
</row>

<row>
<entry>Chemical dihedral angle</entry>
<entry><ulink url="&epydoc;features.Dihedral">Bond dihedral
angle</ulink></entry>
</row>

</tbody>
</tgroup>
</table>

</sect2>

<sect2 id="depfeat">
<title>Dependent and independent features</title>
<para>
An &MDT; <ulink url="&epydoc;Table">Table</ulink> object is simply a table of
counts N(a,b,c,...,d) for features a, b, c, ..., d. However, this is often used
to generate a conditional PDF, p(x,y,...,z | a,b,...,c) for independent features
a, b, ..., c and dependent features x, y, ..., z. By convention in &MDT; the
dependent features are the last or rightmost features in the table, and so
methods which are designed to deal with PDFs such as
<ulink url="&epydoc;Table.smooth">Table.smooth</ulink>,
<ulink url="&epydoc;Table.super_smooth">Table.super_smooth</ulink>,
<ulink url="&epydoc;Table.normalize">Table.normalize</ulink>,
<ulink url="&epydoc;Table.offset_min">Table.offset_min</ulink>, and
<ulink url="&epydoc;Table.close">Table.close</ulink> expect the dependent
features to be the last features. If necessary you can reorder the features
using <ulink url="&epydoc;Table.integrate">Table.integrate</ulink>.
</para>
</sect2>

<sect2 id="binspec">
<title>Specification of bins</title>

<para>
Most features take a <varname>bins</varname> argument when they are created,
which specifies the bin ranges. This is simply a list of (start, end, symbol)
triples, which specify the feature range for each bin, and the symbol to refer
to it by. For example, the following creates an
<ulink url="&epydoc;features.XRayResolution">X-ray resolution</ulink> feature,
with 4 bins, the first for 0.51-1.4 &Aring;,
the second for 1.4-1.6 &Aring;, and so on. Anything below 0.51 &Aring; or 
2.0 &Aring; or above (or an undefined value) will be placed into a fifth
'undefined' bin.
</para>

<example id="binexplicit">
<title>Example feature with explicit bins</title>
<screen>
xray = mdt.features.XRayResolution(mlib, bins=[(0.51, 1.4, "&lt;1.4"),
                                               (1.4,  1.6, "1.4-1.6"),
                                               (1.6,  1.8, "1.6-1.8"),
                                               (1.8,  2.0, "1.8-2.0")])
</screen>
</example>

<note><para>
Bin ranges in &MDT; are half-closed, i.e. a feature value must be greater than
or equal to the lower value of the range, and less than the upper value, to be
counted in the bin. For example, in the case above, 1.0 &Aring; would be placed
into the first bin, and 1.4 &Aring; into the second. (If you define bins with
overlapping ranges, values will be placed into the first bin that matches.)
</para></note>

<para>
In most cases, a set of bins of equal width is desired, and it is
tedious to specify these by hand. A utility function
<ulink url="&epydoc;uniform_bins">uniform_bins</ulink> is provided, which takes
three arguments - the number of bins, the lower range of the first bin,
and the width of each bin - and creates a set of bins; all bins are of the
same size and follow after the first bin. For example, the following bins the
<ulink url="&epydoc;features.AtomDistance">atom-atom distance</ulink> feature
into 60 bins, each 0.5 &Aring; wide, with the first bin starting at 0 &Aring;.
The first bin is thus 0-0.5 &Aring;, the second 0.5-1.0 &Aring;, and so on,
up to bin 60 which is 29.5-30.0 &Aring;. The additional 'undefined' bin thus
counts anything below 0 &Aring;, greater than or equal to 30.0 &Aring;, or which
could not be calculated for some reason).
</para>

<example id="binsequential">
<title>Example feature with sequential bins</title>
<screen>
atdist = mdt.features.AtomDistance(mlib, bins=mdt.uniform_bins(60, 0, 0.5))
</screen>
</example>

</sect2>

<sect2 id="binstorage">
<title>Storage for bin data</title>
<para>
By default, when a table is created in &MDT; it uses double precision floating
point to store the counts. This allows large counts themselves to be accurately
scored, and can also store floating point data such as PDFs. However, for
very large tables, this may use a prohibitive amount of memory. Therefore, it
is possible to change the data type used to store bin data, by specifying
the <varname>bin_type</varname> parameter when creating a
<ulink url="&epydoc;Table">Table</ulink> object. The same parameter can be
given to <ulink url="&epydoc;Table.copy">Table.copy</ulink>, to make a copy
of the table using a different data type for its storage. Note that other
data types use less storage, but can also store a smaller range of counts.
For example, the <ulink url="&epydoc;UnsignedInt8">UnsignedInt8</ulink>
data type uses only a single byte for each bin, but can only store integer
counts between 0 and 255 (floating point values, or values outside of this
range, will be truncated). &MDT; uses double precision floating point for all
internal operations, but any storage of bin values uses the user-selected
bin type. Thus you should be careful not to use an inappropriate bin type -
for example, don't use an integer bin type if you are planning to store PDFs
or perform normalization, smoothing, etc.
</para>

</sect2>
</sect1>

<sect1 id="compilation">
<title>Compilation from source code</title>
<para>
You can get the current &MDT; code, by running the following:
</para>
<screen>
<command>svn co https://svn.salilab.org/impmod/trunk impmod</command>
</screen>

<para>
If you already have a copy of &MDT;, you can update it to the current code
by running
</para>
<screen>
<command>svn update</command>
</screen>

<para>
To compile, create a file called <filename>config.py</filename> in the
<filename>impmod/mdt</filename> directory, and in it set the
<varname>modeller</varname> Python variable to the directory where you have
&MODELLER; installed. Then run <command>scons</command> in the same directory
(and optionally <command>scons test</command>). To install, run
<command>scons prefix=/foo install</command>, which will install &MDT;
in the <filename>/foo</filename> directory.
</para>
</sect1>

<sect1 id="running">
<title>Example &MDT; script</title>
<para>
&MDT; is simply a Python extension module, and as such can be used in
combination with other Python modules, such as &MODELLER;.
</para>

<para>
Generally speaking, to use &MDT;, you should first create a
<ulink url="&epydoc;Library">Library</ulink> object. You can then read in any
necessary additional files, such as
the definitions of chemical bonds (see <xref linkend="chembonds" /> for an
example), or atom tuples. Next, you can define one or more features, which are
classes in the <ulink url="&epydoc;features">features</ulink> module.
Finally, you can create one or more
<ulink url="&epydoc;Table">Table</ulink> objects, using a selection of the
features you added to the Library, to hold the frequency tables
themselves. See <xref linkend="chi1" /> for an example.
</para>

<para>
To run a script <filename>foo.py</filename>, simply run
</para>
<screen>
<command>${MODINSTALLSVN}/bin/modpy.sh python <replaceable>foo.py</replaceable></command>
</screen>

</sect1>

<sect1 id="reference">
<title>&MDT; reference</title>
<para>
See the <ulink url="epydoc/index.html">&MDT; reference manual</ulink> for
documentation on the &MDT; Python interface, generated automatically from
the source code. This describes all of the classes and functions.
</para>

<para>
For information on the low-level &MDT; code, of interest primarily to
developers, see the <ulink url="doxygen/index.html">C API reference</ulink>.
</para>
</sect1>

</chapter>
