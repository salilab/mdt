<chapter id="usage">
<title>Usage</title>

<sect1 id="about">
<title>About &MDT;</title>

<para>
&MDT; prepares a raw frequency table, given information from &MODELLER;
alignments and/or &PDB; files. It can also process the raw frequency table in
several ways (e.g., normalization with
<ulink url="&epydoc;mdt.normalize">mdt.normalize</ulink>, smoothing with
<ulink url="&epydoc;mdt.smooth">mdt.smooth</ulink>), perform entropy
calculations with
<ulink url="&epydoc;mdt.entropy_full">mdt.entropy_full</ulink>, and write
out the data in various formats, including for plotting by &ASGL;
(<ulink url="&epydoc;mdt.write_asgl">mdt.write_asgl</ulink>) and use as
restraints by &MODELLER;.
</para>

<para>
More precisely, &MDT; uses a sample of sequences, structures, and/or
alignments to construct a table N(a,b,c,...,d) for features a, b, c, ..., d.
The sample for generating the frequencies N is obtained depending on the type
of features a, b, c, ..., d. The sample can contain individual proteins, pairs
of proteins, pairs of residues in proteins, pairs of aligned residues, pairs
of aligned pairs of residues, chemical bonds, angles, dihedral angles, and
pairs of tuples of atoms. Some features work with triple alignments, too.
All the needed features a, b, c, ..., d are calculated automatically from the
sequences, alignments, and/or &PDB; files. The feature bins are defined in
a bin file which can be changed by the user.
</para>

<para>
&MDT; works by accumulating the table N by processing each sequence or alignment
in turn. See <ulink url="&epydoc;mdt.add_alignment">mdt.add_alignment</ulink>.
</para>
</sect1>

<sect2 id="features">
<title>&MDT; features</title>

<para>
A 'feature' in &MDT; is simply some binnable property of your input alignment.
Example features include the residue type, &chi; and &Phi; dihedral angles,
sequence identity between two sequences, X-ray resolution, atom-atom distances,
atom type, and bond length.
</para>

<para>
&MDT; understands that different features act on different sets of proteins,
or parts of proteins, and will automatically scan over the correct range to
collect necessary statistics (e.g. when you call
<ulink url="&epydoc;mdt.add_alignment">mdt.add_alignment</ulink>). For example,
to collect statistics for the residue type feature, it is necessary to scan
all residues in all proteins in the alignment. The X-ray resolution feature,
on the other hand, only requires each protein in the alignment to be scanned.
The atom-atom distance feature requires scanning over all pairs of atoms in
all proteins in the alignment, while the sequence identity feature requires
scanning all pairs of proteins in the alignment. If you construct a table of
multiple features, the most fine-grained of the features determines the scan -
for example, a table of X-ray resolution against &Phi; dihedral would require
a scan of all residues. Most features require only one protein in the alignment
('protein A') but some features will act on the second or third protein instead
(protein B or C) while some features act on two or three proteins
simultaneously. See <xref linkend="scantypes" /> for all of the scan types.
</para>

<para>
&MDT; also knows that some features are symmetric, and will perform a
non-redundant scan in this case. If, however, any feature is asymmetric, a
full scan is performed.
</para>

<para>
The bin file determines how to convert a feature value into a frequency table.
For most feature types, you can specify how many bins to use, and their value
ranges. The last bin is always reserved as an 'undefined' bin, for values that
don't fall into any other bin<footnote>
<para>
You can, however, remove the 'undefined' bin using
<ulink url="&epydoc;mdt.reshape">mdt.reshape</ulink>.
</para>
</footnote>.
(Some features are predetermined by the setup of the system - for
example, the residue type feature always has 22 bins - 20 for the standard
amino acids, 1 for gaps in the alignment, and 1 for undefined.)
</para>

<para>
For a list of all defined feature types and suitable default bin ranges,
see the file <filename>mdt.bin</filename>, which you can find in the
<filename>data</filename> subdirectory of the &MDT; source distribution, or
the <filename>modlib</filename> directory after installation.
</para>

<table id="scantypes">
<title>Scan types</title>
<tgroup cols="2">
<thead>
  <row><entry>Type</entry><entry>Example</entry></row>
</thead>
<tbody>

<row>
<entry>Protein</entry>
<entry>Feature 35, X-ray resolution of protein A</entry>
</row>

<row>
<entry>Residue<footnote id="resatompair">
<para>
Residue and residue pair scans are also used for 'one atom per residue'
features, such as feature 16, which is the distance between the 'special
atom' in two residues. This special atom is usually
C<subscript>&alpha;</subscript>, but can be overridden by specifying the
<varname>distance_atoms</varname> parameter when creating the
<ulink url="&epydoc;mdt_library">mdt_library</ulink> object.
</para>
</footnote></entry>
<entry>Feature 4, &chi;<subscript>1</subscript> of protein B</entry>
</row>

<row>
<entry>Residue pair<footnoteref linkend="resatompair" /></entry>
<entry>Feature 51, residue index difference in protein A</entry>
</row>

<row>
<entry>Residue pair</entry>
<entry>Feature 51, residue index difference in protein A</entry>
</row>

<row>
<entry>Atom</entry>
<entry>Feature 79, &MODELLER; atom type in protein A</entry>
</row>

<row>
<entry>Atom pair</entry>
<entry>Feature 82, distance between two atoms in protein A</entry>
</row>

<row>
<entry>Atom tuple</entry>
<entry>Feature 101, atom tuple type in protein A</entry>
</row>

<row>
<entry>Atom tuple pair</entry>
<entry>Feature 103, atom tuple non-bonded distance in protein A</entry>
</row>

<row>
<entry>Chemical bond</entry>
<entry>Feature 109, bond type in protein A</entry>
</row>

<row>
<entry>Chemical angle</entry>
<entry>Feature 112, bond angle in protein A</entry>
</row>

<row>
<entry>Chemical dihedral angle</entry>
<entry>Feature 114, bond dihedral angle in protein A</entry>
</row>

</tbody>
</tgroup>
</table>

</sect2>

<sect1 id="compilation">
<title>Compilation from source code</title>
<para>
You can get the current &MDT; code, by running the following:
</para>
<screen>
<command>svn co svn+ssh://synth.ucsf.edu/synth2/home/svn/imp/trunk imp</command>
</screen>

<para>
If you already have a copy of &MDT;, you can update it to the current code
by running
</para>
<screen>
<command>svn update</command>
</screen>

<para>
To compile, set the <varname>MODINSTALLSVN</varname> environment variable to
where you have &MODELLER; installed and run <command>scons</command> in the
<filename>imp/mdt</filename> directory (and optionally
<command>scons test</command>). To install, run
<command>scons install</command>, which will install the &MDT;
libraries in the same directories as &MODELLER;.
</para>
</sect1>

<sect1 id="running">
<title>Example &MDT; script</title>
<para>
&MDT; is simply a Python extension module, and as such can be used in
combination with other Python modules, such as &MODELLER;.
</para>

<para>
Generally speaking, to use &MDT;, you should first create an
<ulink url="&epydoc;mdt_library">mdt_library</ulink> object. This defines
the bin ranges, and in most cases is the only prerequisite for creating
MDT tables themselves<footnote>
<para>
Some library information needs to be read from additional files, such as
the definitions of chemical bonds (see <xref linkend="chembonds" /> for an
example), or atom tuples.
</para>
</footnote>. You can then create one or more
<ulink url="&epydoc;mdt">mdt</ulink> objects which hold the frequency tables
themselves. See <xref linkend="chi1" /> for an example.
</para>

<para>
To run a script <filename>foo.py</filename>, simply run
</para>
<screen>
<command>${MODINSTALLSVN}/bin/modpy.sh python <replaceable>foo.py</replaceable></command>
</screen>

</sect1>

<sect1 id="reference">
<title>&MDT; reference</title>
<para>
See the <ulink url="epydoc/index.html">&MDT; reference manual</ulink> for
documentation on the &MDT; Python interface, generated automatically from
the source code.
</para>
</sect1>

</chapter>
